/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type MonitoringGroupObservation struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type MonitoringGroupParameters struct {

	// A user-assigned name for this group, used only for display
	// purposes.
	// +kubebuilder:validation:Required
	DisplayName *string `json:"displayName" tf:"display_name,omitempty"`

	// The filter used to determine which monitored resources
	// belong to this group.
	// +kubebuilder:validation:Required
	Filter *string `json:"filter" tf:"filter,omitempty"`

	// If true, the members of this group are considered to be a
	// cluster. The system can perform additional analysis on
	// groups that are clusters.
	// +kubebuilder:validation:Optional
	IsCluster *bool `json:"isCluster,omitempty" tf:"is_cluster,omitempty"`

	// The name of the group's parent, if it has one. The format is
	// "projects/{project_id_or_number}/groups/{group_id}". For
	// groups with no parent, parentName is the empty string, "".
	// +kubebuilder:validation:Optional
	ParentName *string `json:"parentName,omitempty" tf:"parent_name,omitempty"`

	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`
}

// MonitoringGroupSpec defines the desired state of MonitoringGroup
type MonitoringGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MonitoringGroupParameters `json:"forProvider"`
}

// MonitoringGroupStatus defines the observed state of MonitoringGroup.
type MonitoringGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MonitoringGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MonitoringGroup is the Schema for the MonitoringGroups API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfgcp}
type MonitoringGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MonitoringGroupSpec   `json:"spec"`
	Status            MonitoringGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MonitoringGroupList contains a list of MonitoringGroups
type MonitoringGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MonitoringGroup `json:"items"`
}

// Repository type metadata.
var (
	MonitoringGroupKind             = "MonitoringGroup"
	MonitoringGroupGroupKind        = schema.GroupKind{Group: Group, Kind: MonitoringGroupKind}.String()
	MonitoringGroupKindAPIVersion   = MonitoringGroupKind + "." + GroupVersion.String()
	MonitoringGroupGroupVersionKind = GroupVersion.WithKind(MonitoringGroupKind)
)

func init() {
	SchemeBuilder.Register(&MonitoringGroup{}, &MonitoringGroupList{})
}
